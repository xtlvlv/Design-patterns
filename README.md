
[toc]
### 置顶

1. 这是对《Head First 设计模式》这本书的C++代码实现，书中是用Java实现的，理论知识在 [《HF 设计模式》笔记]()中记录的有。
2. 入门级程序，都是很简单的例子
3. 通过这个学习，我学到了各种设计模式的知识，而且对C++的virtual更加熟悉，和Java的abstract,interface
4. 所有代码在Ubuntu18.04下编译运行成功，makefile文件虽然比较low，但make一下还是能成功编译的
    ```
    $ make
    $ ./out
    ```

### 1. 策略模式
1. 前几个都想把目录整的标准一点，所以看着有点乱，不过不准备改了，记录学习过程吧
2. 这是一个"鸭子动态选择行为类"的例子，极其简单，没啥说的

### 2. 观察者模式
1. 主要是实现observe和observable接口，observable里要实现必要的regist(),remove(),notify()方法，其他根据情况拓展
2. 目录还是四不像

### 3. 装饰器模式
1. 继承自同一个基类，新的类在原来的类上添加东西。

### 4. 工厂模式
- 从这个开始，不再弄花里胡哨的目录了，一个项目放一个目录下，文件不多，建目录麻烦

##### 简单工厂
1. 不是模式，一种编程习惯，就是把所有完成某个功能的代码放在一个类里，当做"工厂"
2. 实现一个制作Pizza的例子

##### 工厂方法
1. 就是定义好基类工厂，根据需要看实现哪个具体的工厂
2. 制作Pizza的例子，能制作不同地方的Pizza

##### 抽象工厂
1. 和工厂方法的区别，我理解就是用接口定义了一种由该接口衍生出的一个"家族"
2. Pizza例子，多了个原料的接口，定义了原料"家族"

### 5. 单件模式
1. 单实例模式，没啥说的，主要就是多线程如何处理，用java可以很方便的用同步，用C++就加锁，需要结合平台。也可以用Boost的锁方法
2. 这也算是我第一次用boost吧。。。

### 6. 命令模式
1. 就是把每个命令当做一个类处理，保持类的状态，这样可以实现命令队列，日志恢复什么的，有点东西。
2. 实现了一个遥控器控制灯开关的例子，还可以再加其他命令，不过没有必要。

### 7. 适配器和外观模式
##### 适配器
1. 就是改变类的接口，适配于其他 没有这个类接口 的地方
2. 实现火鸡接口适配火鸡，让其能用到需要鸭子的地方

##### 外观模式
1. 就是对方法、各种功能的封装，让调用更方便
2. 实现了一个 播放电影 的例子

### 8. 模板方法模式
1. 基类定义一个大的框架，子类重载某些需要改变的方法
2. 实现了一个 制作饮料 的例子

### 9. 迭代器和组合模式
1. 就是C++/Java中Iterator的意思，如果不懂Iterator是什么，，，可以先学学Iterator
2. 实现了一个数组模拟栈，然后用迭代器能对栈全部顺序访问的例子

### 10. 状态模式
1. 和策略模式有一点像，不过策略一般是初始化后不咋变动，状态是一直在变，用类表示各种状态，实现该状态对各种方法的处理
2. 实现了一个 投币游戏机 的例子
3. 不过C++代码编译不能通过，报错搜也搜不到，只能暂时搁置，哪位大佬看到了望指教一下。。。我估摸者会不会是在构造方法里不能传this指针给其他类当做构造函数的参数？
4. 因为C++编译不通过，也找不到问题所在，就用Java实现了一遍，运行有一些逻辑BUG，Java版本的已改，C++版本的因为还未编译通过，逻辑BUG也没改。

### 11. 最后
1. 代理模式和复合模式就不实现了，代理不容易找例子，复合就是各种模式的结合
2. 还有许多其他模式，《Head Fiest 设计模式》略讲，目前我也是略看，没有代码实现。

